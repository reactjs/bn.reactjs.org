---
id: thinking-in-react
title: React-উপায়ে চিন্তা করা
permalink: docs/thinking-in-react.html
redirect_from:
- 'blog/2013/11/05/thinking-in-react.html'
- 'docs/thinking-in-react-zh-CN.html'
prev: composition-vs-inheritance.html
---

  আমাদের মতে, বড় এবং দ্রুতগতির ওয়েব অ্যাপ্লিকেশন বানাবার জন্য সবচেয়ে ভাল উপায় হচ্ছে React   

  React এর অনেক গুলো অসাধারণ ব্যাপারের একটি হচ্ছে, যখন আপনি React ব্যবহার করে একটি অ্যাপ্লিকেশন তৈরী করেন তখন React আপনাকে ওই অ্যাপ্লিকেশন সম্বন্ধে যেভাবে ভাবায় তা। ধরুন আপনি সার্চ করা যায় এমন একটু ডেটা টেবল বানাতে চাচ্ছেন। এই অ্যাপ্লিকেশনটি রিয়েক্ট দিয়ে বানালে আপনার চিন্তাধারা কেমন হবে সেটি আমরা এই লেখাটিতে দেখানোর চেষ্টা করব।    

  ## একটি মক দিয়ে শুরু করুন  {#start-with-a-mock}

  ধরে নিন, আপনার কাছে ইতোমধ্যে একটি JASON API এবং একটি মক রয়েছে যা আপনি ডিজাইনারের কাছ থেকে পেয়েছেন। সেটি দেখতে এমন:

![Mockup](../images/blog/thinking-in-react-mock.png)

আমাদের JASON API কিছু ডেটা পাঠায় যা এমন: 
  
```
[
{category: "Sporting Goods", price: "$49.99", stocked: true, name: "Football"},
{category: "Sporting Goods", price: "$9.99", stocked: true, name: "Baseball"},
{category: "Sporting Goods", price: "$29.99", stocked: false, name: "Basketball"},
{category: "Electronics", price: "$99.99", stocked: true, name: "iPod Touch"},
{category: "Electronics", price: "$399.99", stocked: false, name: "iPhone 5"},
{category: "Electronics", price: "$199.99", stocked: true, name: "Nexus 7"}
];
```

##  ধাপ ১ :  UI কে একটি কম্পোনেন্ট Hierarchy তে ভেঙে ফেলুন   {#step-1-break-the-ui-into-a-component-hierarchy}

যেটা আপনার একদম শুরুতে করা উচিত সেটা হল প্রতিটা কম্পোনেন্ট (এবং সাবকম্পোনেন্ট) এর চারিদিকে একটি বক্স আঁকানো এবং প্রতিটার একটি নাম দেওয়া। আপনি যদি একজন ডিজাইনারের সাথে কাজ করে থাকেন উনি হয়ত ইতোমধ্যেই এগুলোর নাম দিয়ে রেখেছেন। সুতরাং উনার সাথে কথা বলুন! উনার ফটোশপ লেয়ারের নামই হয়ত হতে পারে আপনার React কম্পোনেন্ট এর নাম!

কিন্তু আপনি কিভাবে জানবেন যে কোন কাজটার নিজেরই একটি কম্পোনেন্ট থাকা দরকার? যখন সিদ্ধান্ত নিয়ে থাকেন যে একটি ফাংশন তৈরী করবেন নাকি একটি অবজেক্ট, তখন যেভাবে চিন্তা করেন, ঠিক সেভাবেই এই সিদ্ধান্তটিও নেওয়া সম্ভব। এমন একটি পরিচিত পদ্ধতি হল [single responsibility principle](https://en.wikipedia.org/wiki/Single_responsibility_principle), যা মূলত বলে যে, একটা কম্পোনেন্ট   আদর্শগতভাবে একটি কাজই করা উচিত। যদি এটি বড় হয়ে যায়, তাহলে এটিকে ভেঙে ছোট ছোট সাবকম্পোনেন্ট এ ভাগ করে ফেলতে হবে।  

যেহেতু আপনি প্রায়শই অ্যাপ্লিকেশন ব্যবহারকারীকে একটি JSON ডেটা মডেল দেখাচ্ছেন, খেয়াল করে থাকবেন আপনার মডেল যদি সঠিকভাবে বানানো হয়ে থাকে, আপনার (এবং আপনার কম্পোনেন্ট এর গঠনবিন্যাস) সুন্দরমত মিলে যাবে। এর কারণ হচ্ছে UI এবং ডেটা মডেল একই *ইনফরমেশন আর্কিটেকচার* কে অনুসরণ করে। আপনার UI কে কম্পোনেন্ট এ এমন ভাবে ভেঙে ফেলুন যেন আপনার ডেটা মডেল এর প্রতিটি অংশের জন্য একটি করে কম্পোনেন্ট খাপ খায়।
  
![Component diagram](../images/blog/thinking-in-react-components.png)

এখানে আপনি দেখতে পাচ্ছেন, আমাদের অ্যাপ্লিকেশন এ পাঁচটি কম্পোনেন্ট রয়েছে। প্রতিটা কম্পোনেন্ট যে তথ্য দেখাচ্ছে সেগুলো আমরা ইটালিক করে দিয়েছি।   

  1.  **`FilterableProductTable` (কমলা):** এর মধ্যে পুরো উদাহরণটি রয়েছে
  2.  **`SearchBar` (নীল):** এই অংশটি  সব *ইউজার ইওনুট* পায়  
  3.  **`ProductTable` (সবুজ ):** *ইউজার ইনপুট* এর নিরিখে *ডেটা কালেকশন* দেখায় এবং ফিল্টার করে 
  4.  **`ProductCategoryRow` (টারকোয়াইজ ):**  *ক্যাটাগরী* এর জন্য একটি শিরোনাম দেখায় 
  5.  **`ProductRow` (লাল):** প্রতিটি *পণ্যের* জন্য একটি সারি   দেখায় 
 
  যদি `ProductTable` এর দিকে লক্ষ্য করা হয় তবে দেখা যাবে টেবলের শিরোনাম (যার মধ্যে "Name" এবং "Price" লেবেলগুলো রয়েছে) এর নিজের কম্পোনেন্ট নয়। এটি কিছুটা ব্যক্তিগত পছন্দের বিষয়। এর যেকোন দিকেই যুক্তি প্রদর্শন সম্ভব। এই উদাহরণের ক্ষেত্রে আমরা এটিকে `ProductTable` এর একটি অংশ হিসেবে রেখেছি, কারণ এটি *ডেটা কালেকশন* দেখানোর অংশ। এবং  *ডেটা কালেকশন* এর দায়িত্ব বর্তায় `ProductTable` এর উপর। তবে, অ্যাপ্লিকেশনটি হয়ত আরো বড় হবে এবং এই শিরোনাম জটিল আকার ধারণ করতেই পারে (যেমন সর্ট করার আরো কিছু উপায় যোগ করা হল)। সেই ক্ষেত্রে শিরোনাম এর জন্য আলাদা কম্পোনেন্ট `ProductTableHeader`বানানো যথেষ্ট যুক্তিযুক্ত হবে।    

  এখন যেহেতু আমরা আমাদের মক এর জন্য কম্পোনেন্ট চিহ্নিত করে ফেলেছি, সেহেতু আমরা এদেরকে একটি hierarchy তে সাজিয়ে ফেলতে পারি। যেই কম্পোনেন্ট গুলো অন্য একটি কম্পোনেন্ট এর মধ্যে দেখা যায় সেগুলো hierarchyতে চাইল্ড  হিসেবে দেখতে হবে:

  * `FilterableProductTable`
    * `SearchBar`
    * `ProductTable`
      * `ProductCategoryRow`
      * `ProductRow`

## ধাপ ২ঃ React ব্যবহার করে একটি স্ট্যাটিক ভার্শন তৈরি করা {#step-2-build-a-static-version-in-react}

<p data-height="600" data-theme-id="0" data-slug-hash="BwWzwm" data-default-tab="js" data-user="lacker" data-embed-version="2" class="codepen">See the Pen <a href="https://codepen.io/gaearon/pen/BwWzwm">Thinking In React: Step 2</a> on <a href="https://codepen.io">CodePen</a>.</p>
<script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script>

এখন যেহেতু আপনার কাছে কম্পোনেন্টের hierarchy তৈরী করা আছে, এখন অ্যাপ্লিকেশনটি তৈরি করে ফেলার পালা। সবচেয়ে সহজ উপায় হচ্ছে অ্যাপ্লিকেশনটির এমন একটি ভার্শন তৈরী করা যা আপনার ডেটা মডেলটি গ্রহণ করে UI দেখাবে। কিন্তু এতে কোন interaction করা যাবে না অর্থাৎ স্ট্যাটিক হবে এটি। এই দুইটা কাজকে আলাদা করাই সবচেয়ে ভাল বুদ্ধি এই কারণে যে, স্ট্যাটিক ভার্শন তৈরী করার ক্ষেত্রে প্রচুর কোড লিখতে হয়, কিন্তু চিন্তা করতে হয় কম। অন্যদিকে অ্যাপ্লিকেশনটিকে interactive বা সচল করতে হলে অনেক অনেক চিন্তা করতে হবে কিন্তু লিখতে হবে কম। এটা কেন হচ্ছে তা আমরা এখনি দেখতে পাব।

আপনার অ্যাপ এর স্ট্যাটিক ভার্শন যা শুধুমাত্র আপনার তৈরি করা ডেটা মডেল দেখাবে, সেটি তৈরি করতে আপনি এমন কিছু কম্পোনেন্ট বানাতে চাইবেন যা অন্য কম্পোনেন্ট কে বার বার ব্যবহার করে। এবং *প্রপ্স(props)* ব্যবহার করে ডেটা আদান প্রদান করে। *প্রপ্স* হচ্ছে প্যারেন্ট কম্পোনেন্ট থেকে চাইল্ড কম্পোনেন্ট এ ডেটা পাঠানোর একটি মাধ্যম। যদি আপনি *স্টেট(state)* এর বিষয়ে ধারণা থেকে থাকেন, এই স্ট্যাটিক ভার্শনটি তৈরী করতে **অবশ্যই স্টেট ব্যবহার করবেন না**। স্টেট শুধুমাত্র অ্যাপটি সচল করার জন্য ব্যবহার করা হবে। অর্থাৎ, শুধুমাত্র সেই ডেটার জন্য যা সময়ের সাথে সাথে পরিবর্তিত হতে পারে। যেহেতু এটি একটি স্ট্যাটিক ভার্শন আপনার স্টেট এর কোন প্রয়োজনই নেই।

আপনি উপর থেকে নিচে (টপ-ডাউন) বা নিচে থেকে উপরে (বটম আপ) পদ্ধতিতে অ্যাপটি তৈরি করতে পারেন। অর্থাৎ আপনি শুরুতে hierarchy এর উপরের দিকের কম্পোনেন্টগুলো আগে তৈরি করতে পারেন (যেমন `FilterableProductTable` দিয়ে শুরু করা), অথবা নিচের দিকের কম্পোনেন্ট দিয়ে শুরু করতে পারেন (`ProductRow`)। অপেক্ষাকৃত সহজ কোন উদাহরণে সাধারণত টপ-ডাউন তৈরি করাই ভাল, অন্যদিকে একটু বড় ধরণের কোন অ্যাপ্লিকেশনে বটম-আপ তৈরি করলে সহজ হয়। এক্ষেত্রে আপনি শুরু থেকেই টেস্ট এর জন্য কোড করে আগানো ভাল।

এই ধাপের শেষে পুনর্ব্যবহার করা যায় এমন কিছু কম্পোনেন্ট এর লাইব্রেরী আপনার কাছে থাকবে। এই কম্পোনেন্ট গুলার শুধুমাত্র একটি মেথড ই থাকবে, এবং তা হচ্ছে `render()`। কারণ, এটি আপনার অ্যাপ এর একটি স্ট্যাটিক ভার্শন। Hierarchy এর মাথায় অবস্থান করা কম্পোনেন্ট (`FilterableProductTable`) আপনার ডেটা মডেলকে একটি প্রপ হিসেবে গ্রহণ করবে। আপনি যদি আপনার ডেটা মডেলে কোন পরিবর্তন করেন এবং `ReactDOM.render()` মেথডটিকে আবার কল করেন, UI আবার সে হিসেবে আপডেটেড হয়ে যাবে। আপনি এখন দেখতে পাচ্ছেন আপনার UI তে পরিবর্তন আনতে কোডের কোথায় পরিবর্তন ঘটাতে হবে। React এর **one-way data flow** বা একমুখী তথ্য প্রবাহ (যাকে *one-way binding* ও বলা হয়)  সবকিছু কে মডুলার এবং দ্রুতগতির রাখে। 

এই ধাপটি সম্পন্ন করতে যদি সাহায্য প্রয়োজন হয়, [React ডকুমেন্টেশন](/docs/)এ দেখতে পারেন।

### অল্প একটু হস্তক্ষেপ: প্রপ বনাম স্টেট {#a-brief-interlude-props-vs-state}

React এ দু'ধরণের "model" বা আদর্শ ডেটা আছেঃ প্রপ (prop) আর স্টেট (state)। এদের মধ্যকার পার্থক্য জানা খুবই দরকার। যদি আপনি এই পার্থক্য সম্বন্ধে নিশ্চিত না হয়ে থাকেন, তাহলে [the official React docs](/docs/interactivity-and-dynamic-uis.html)এ চোখ বুলিয়ে দেখতে পারেন। 

## Step 3: UI State এর যৎসামান্য(কিন্তু পরিপূর্ণ) অবস্থা চিহ্নিত করুন  {#step-3-identify-the-minimal-but-complete-representation-of-ui-state}

UI কে সচল করতে চাইলে আপনাকে ডেটা মডেল এ পরিবর্তন করার একটা ব্যবস্থা করতে হবে। আর React এই লক্ষ্য অর্জন করে **স্টেট** ব্যবহার করে. 

আপনার অ্যাপটি সঠিকভাবে তৈরি করতে হলে সেই সর্বনিম্ন সংখ্যক স্টেট এর কথা ভাবতে হবে যা অ্যাপটির প্রয়োজন। এখানে বুদ্ধিটা হল [DRY: *Don't Repeat Yourself*](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) অর্থাৎ কোন একটি কাজ একবারের বেশি না করার চেষ্টা করতে হবে।  আপনার অ্যাপ্লিকেশন এর সেই যৎসামান্য স্টেট চিহ্নিত করুন, অ্যাপ্লিকেশনটির প্রয়োজন এবং যেগুলো আপনার সকল প্রয়োজনে ব্যবহার করা যথেষ্ট। ধরুন, আপনি একটা TODO list অ্যাপ বানাতে চাচ্ছেন। সেইক্ষেত্রে লিস্টে কি কি আছে তা গুণে বের করবার জন্য কোন স্টেট রাখবেন না, বরং লিস্টের সব কিছু একটি অ্যারে(array) তে রাখুন এবং ফলস্বরূপ লিস্টে কয়টি আইটেম আছে তা বের করার জন্য লিস্টের অ্যারের সাইজ জানাই যথেষ্ট।

এবার আমাদের উদাহরণের যে অ্যাপ্লিকেশন, সেখানে প্রতিটি অংশের কথা আবার চিন্তা করি। আমাদের যা আছে, তা হল:

  * পণ্যের মূল তালিকা
  * ব্যবহারকারী সার্চ করার জন্য যা লিখেছে
  * চেকবক্সের ভ্যালু
  * পণ্যের ফিল্টার করা তালিকা 

এখন প্রতিটি বিষয়ে তিনটি প্রশ্ন নিজেকে নিজে জিজ্ঞেস করে আমরা জেনে নিতে পারি কোনটার স্টেট থাকবে এবং কোনটার থাকবে নাঃ

  1. একে প্রপ এর সাহায্যে প্যারেন্ট কম্পোনেন্ট থেকে চাইল্ড কম্পোনেন্ট এ পাঠানো হয় ? যদি হয়, তাহলে সম্ভবত এটি স্টেট না।
  2. এটি কি সময়ের সাথে অপরিবর্তিত থাকে ? যদি থাকে, তাহলে এটি সম্ভবত স্টেট না।
  3. একে কি অন্য কোন স্টেট বা প্রপ এর উপর নির্ভর করে হিসেব করা যায় ? যদি যায়, তাহলে এটি সম্ভবত স্টেট নয়।

যেহেতু পণ্যের মূল তালিকা প্রপ হিসেবে এদিক সেদিক করা হচ্ছে, সেহেতু তা স্টেট হতে পারে না। সার্চ টেক্সট এবং চেকবক্স সম্ভবত স্টেট, কারণ এগুলোকে অন্য কোন কম্পোনেন্ট এর উপর নির্ভর করে হিসেব করা যায় না এবং এরা সময়ের সাথে পরিবর্তিত হয়। এরং অবশেষে পণ্যের ফিল্টার করা তালিকা স্টেট না, কারণ তা সার্চ টেক্স এবং চেকবক্সের মান থেকে হিসেব করা সম্ভব।   

অর্থাৎ পরিশেষে বলতে পারি, আমাদের স্টেটগুলো হল:

  * ইউজার সার্চ বক্সে যা লিখেন
  * চেকবক্সের মান

## ধাপ ৪: আপনার স্টেটটি কোথায় থাকা উচিত তা চিহ্নিত করা {#step-4-identify-where-your-state-should-live}

<p data-height="600" data-theme-id="0" data-slug-hash="qPrNQZ" data-default-tab="js" data-user="lacker" data-embed-version="2" class="codepen">See the Pen <a href="https://codepen.io/gaearon/pen/qPrNQZ">Thinking In React: Step 4</a> on <a href="https://codepen.io">CodePen</a>.</p>

আচ্ছা, তো আমরা আমাদের অ্যাপ এর একদম মিনিমাল বা সর্বনিম্ন অবস্থা বের করে ফেললাম। এখন, আমাদের বের করে ফেলতে হবে কোন কম্পোনেন্ট এর মধ্যে এই স্টেট গুলা থাকবে, অর্থাৎ কোন কম্পোনেন্ট গুলো এই স্টেট গুলোকে পরিবর্তিত(mutate) বা *অধিকার* করে।

মনে রাখুন: React এর মূল বিষয়ই হচ্ছে কম্পোনেন্ট hierarchy দিয়ে একমুখী ডেটা ফ্লো বা তথ্য প্রবাহ। প্রথমেই হয়ত বুঝা যাবে না কোন কম্পোনেন্ট কোন স্টেটকে নিজের করে রাখবে বা পরিবর্তন করার অধিকার রাখবে। **এটা প্রায়শই নতুনদের বুঝবার জন্য সবচেয়ে কঠিন বিষয় হিসেবে দেখা যায়।** সুতরাং, নিচের এই ধাপগুলো অনুসরণ করে বুঝবার চেষ্টা করুন: 

আপনার অ্যাপ এর প্রতিটি স্টেট এর জন্য:

  * সেই প্রতিটি কম্পোনেন্ট চিহ্নিত করুন যেটা এই স্টেট এর নিরিখে কোন কিছু প্রদর্শন করে।
  * একটি সাধারণ owner কম্পোনেন্ট খুজে বের করুন(একটি মাত্র কম্পোনেন্ট যেটি hierarchy অনুসারে সেই সব কম্পোনেন্টকে অধিকার করে যেগুলো এই স্টেটকে চাচ্ছে) 
  * এই সাধারণ অধিকর্তা কম্পোনেন্ট বা তার চেয়েও উপরের কোন কম্পোনেন্ট এর অধিকারে স্টেটটি থাকা উচিত। 
  * যদি এমন কোন কম্পোনেন্ট আপনি খুঁজে না পান, তাহলে শুধুমাত্র এই স্টেটের জন্য একটি কম্পোনেন্ট তৈরি করুন যা hierarchy তে ওই সাধারণ কম্পোনেন্ট এর উপরে থাকে।   

এখন এই বুদ্ধিটাই আমরা আমাদের উদাহরণের অ্যাপ্লিকেশনে কাজে লাগানোর চেষ্টা করি:

  * `ProductTable` এর দরকার স্টেট এর নিরিখে পণ্য ফিল্টার করা। অন্যদিকে `SearchBar` এর সার্চ টেক্সট এবং চেকড স্টেট দেখানো প্রয়োজন।   
  * Hierarchy তে যে সাধারণ owner কম্পোনেন্ট আমরা পাই তা হল `FilterableProductTable`
  * সুতরাং, ধারণাগতভাবে এই `FilterableProductTable` কম্পোনেন্ট এই ফিল্টার টেক্সট এবং চেকবক্সের মান রাখাটা যুক্তিযুক্ত হয়।

অসাধারণ! সুতরাং আমরা সিদ্ধান্ত নিয়ে ফেললাম যে আমাদের স্টেট টি `FilterableProductTable` কম্পোনেন্ট এ থাকা দরকা। প্রথমে একটি instance property `this.state = {filterText: '', inStockOnly: false}` এই কম্পোনেন্ট এর `constructor` এ যোগ করতে হবে। যেন, এটি আপনার অ্যাপ্লিকেশনের একদম শুরুর অবস্থা এটি নির্দেশ করতে পারে। এখন `filterText` এবং `inStockOnly` কে `ProductTable` এবং `SearchBar`তে প্রপ হিসেবে পাঠিয়ে দিন (pass করুন)। অবশেষে, এই প্রপগুলোকে ব্যবহার করে `ProductTable` এর সারিগুলো ফিল্টার করুণ এবং `SearchBar` এর ফর্ম ফিল্ড এর মানগুলো ঠিক করে ফেলুন।

এখন আপনি চাইলে দেখে নিতে পারেন আপনার অ্যাপ্লিকেশন কেমন আচরণ করবে: `filterText` এর মান `"ball"` দিয়ে অ্যাপ্লিকেশন রিফ্রেশ করুন এবং দেখুন আপনার ডেটা টেবল সঠিকভাবে আপডেটেট হয়ে গেছে।

## ধাপ ৫: বিপরীত তথ্য প্রবাহ যোগ করুন {#step-5-add-inverse-data-flow}

<p data-height="600" data-theme-id="0" data-slug-hash="LzWZvb" data-default-tab="js,result" data-user="rohan10" data-embed-version="2" data-pen-title="Thinking In React: Step 5" class="codepen">See the Pen <a href="https://codepen.io/gaearon/pen/LzWZvb">Thinking In React: Step 5</a> on <a href="https://codepen.io">CodePen</a>.</p>

এতক্ষণ পর্যন্ত আমরা একটি অ্যাপ বানিয়েছি যা hierarchy দিয়ে উপর থেকে নিচে বয়ে যাওয়া state এবং prop এর কারণে সব কিছু সঠিকভাবে দেখাতে পারে। এখন সময় হল তথ্য প্রবাহকে উল্টোদিকে যাবার সুযোগ দেওয়া: অর্থাৎ hierarchy এর গভীরে থাকা ফর্ম কম্পোনেন্টকে `FilterableProductTable` এর স্টেট পরিবর্তনের ব্যবস্থা করে দেওয়া। 

React এর এই তথ্য প্রবাহ পরিচ্ছন্ন ও স্পষ্ট হবার সবচেয়ে বড় কারণ, যেন আপনি বুঝতে পারেন আপনার প্রোগ্রাম কিভাবে কাজ করে। কিন্তু, প্রথাগত দ্বিমুখী তথ্য প্রবাহ (traditional two-way data binding) এর চেয়ে এক্ষেত্রে কোড একটু বেশি করতে হয়।

যদি আপনি এই উদাহরণের এখনকার ভার্শনে চেক বক্সে টিক দিয়েও দেন, দেখবেন React আপনার ইনপুট গ্রহণ করছে না। এইটা ইচ্ছা করেই করা হয়েছে, যেহেতু আমরা  `input` এর `value` প্রপটি সবসময়  `FilterableProductTable` থেকে আসা `state` এর সমান করেছি।

তাহলে এবার চিন্তা করি আমরা কি ঘটাতে চাচ্ছি। আমরা চাচ্ছি যে, যখনই ব্যবহারকারী ফর্ম এ কোন পরিবর্তন আনবেন, তখন স্টেট ও যেন সেভাবে পরিবর্তিত হয়। যেহেতু শুধুমাত্র কম্পোনেন্ট এর ই উচিত নিজেদের স্টেট পরিবর্তন করা, সেহেতু যখনই স্টেট বদলানোর দরকার পড়বে, `FilterableProductTable` কম্পোনেন্টটি  `SearchBar` এ কলব্যাক (callback) পাঠাবে। আমরা `onChange` ইভেন্টটি ব্যবহার করে কখন ইনপুটে পরিবর্তন আসছে সে বিষয়ে খবর পেতে পারি। `FilterableProductTable` এর কলব্যাকগুলো `setState()` কে কল করবে, এবং অ্যাপ্লিকেশনটি আপডেটেড হয়ে যাবে। 

## ব্যাস! হয়ে গেল {#and-thats-it}

আশা করা যায়, এই লেখাটি React ব্যবহার করে কম্পোনেন্ট এবং অ্যাপ্লিকেশন তৈরি করবার সময়ে কিভাবে চিন্তা করতে হবে সে বিষয়ে কিছুটা ধারণা দেবে। এটা সত্য যে প্রথাগত পদ্ধতির চেয়ে বেশি কোড করতে হচ্ছে এখানে। তবে মনে রাখতে হবে, কোড যতটা না লেখা হয় তার চেয়ে অনেক বেশি পড়া হয়, এবং এ ধরণের পরিচ্ছন্ন, স্পষ্ট ও বিভিন্ন মডিউলে ভাগ করা (মডুলার) কোড পড়াটা অপেক্ষাকৃত সহজ। যখন আপনি কম্পোনেন্ট এর বিশাল লাইব্রেরি বানানো শুরু করবেন, তখন এই পরিচ্ছন্নতা এবং মডুলারিটির বিষয়টা আপনার অনেক ভাল লাগবে। একই সাথে কোডগুলোর বার বার ব্যবহারে আপনার লেখা মোট কোডের পরিমাণ কমে যাবে অনেক। শুভ কামনা রইল। Happy coding :) 
